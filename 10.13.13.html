<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />	

	<title> 10-13-2013 </title>
</head>
<body>
<h1> Noted For October 13th, 2013 </h1>
<ul>
	<div>
		<h2> 
			<a href="http://www.joelonsoftware.com/articles/Unicode.html" target="_blank"> Joel Spolsky: The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets </a>
		</h2>
		<p>
			I've been dismayed to discover just how many software developers aren't really completely up to speed on the mysterious world of character sets, encodings, Unicode, all that stuff...[Most programmers wish] it would all blowever somehow.
		</p>
		<p> Back in the semi-olden days, when Unix was being invented and K&R were writing The C Programming Language, everything was very simple. EBCDIC was on its way out. The only characters that mattered were good old unaccented English letters, and we had a code for them called ASCII which was able to represent every character using a number between 32 and 127.
		</p>
		<p> Eventually this OEM free-for-all got codified in the ANSI standard. In the ANSI standard, everybody agreed on what to do below 128, which was pretty much the same as ASCII, but there were lots of different ways to handle the characters from 128 and on up, depending on where you lived. These different systems were called code pages. So for example in Israel DOS used a code page called 862, while Greek users used 737. They were the same below 128 but different from 128 up, where all the funny letters resided...But still, most people just pretended that a byte was a character and a character was 8 bits and as long as you never moved a string from one computer to another, or spoke more than one language, it would sort of always work. But of course, as soon as the Internet happened, it became quite commonplace to move strings from one computer to another, and the whole mess came tumbling down. Luckily, Unicode had been invented.
	</p>
	<p> In Unicode, a letter maps to something called a code point which is still just a theoretical concept...that's where encodings come in...thus was invented the brilliant concept of UTF-8...There are acutally a bunch of otherways to of encoding Unicode...It does not make sense to have a string without knowing what type of encoding it uses.  You can no longer stick your head in the sand and pretend plain text is ASCII: There ain't no such thing as plain text <a href="http://www.joelonsoftware.com/articles/Unicode.html" target="_blank"> Continue Reading ...</a>
		</p>
	</div>
	<div>
		<h2> 
			<a href="http://election.princeton.edu/2013/10/10/a-prediction-for-2014-house-elections-take-1/"> Sam Wang: Democrats Chance of House Takeover at 50%  </a>
		</h2>
		<p> The incredible numbers in yesterday’s NBC/WSJ poll pretty much demonstrate that point: approval of the Republican party is at an all-time low…and 60% of voters would vote out every single member of Congress at once including their own if given the chance.
		</p>
		<p> Today I start to outline a true prediction. I give a “toy model,” i.e. step 1 toward something more realistic. The toy model relies on a prediction of popular vote only.
		</p>
		<p>
		Provisionally, it looks like the following: In a little over a week, the shutdown has increased the probability of a Democratic House takeover in 2014 from 13% to as high as 50%.
		</p>
		<p> ...the shutdown, combined with the fluidity of gerrymandered districts, has added a highly unexpected twist. The 50% figure could swing back toward the Republicans, or it could go further toward the Democrats. <a href="http://election.princeton.edu/2013/10/10/a-prediction-for-2014-house-elections-take-1/"> Continue Reading ... </a>
		</p>
	</div>
	<div>
		<h2>
			<a href="http://plan9.bell-labs.com/sys/doc/utf.pdf">Ken Thompson, Rob Pike: Hello World: Unicode Support on Plan 9 </a>
		</h2>
		<p> The world is multilingual but most computer systems are based on English and ASCII. The first release of Plan 9 [Pike90], a new distributed operating system from Bell Laboratories, seemed a good occasion to correct this chauvinism...This paper reports what we discovered as we explored the problem of representing multilingual text at all levels of an operating system, from the file system and kernel through the applications and up to the window system and display. </p>
	<p> Our first step was to select a standard. At the time (January 1992), there were only two viable options: ISO 10646 [ISO10646] and Unicode [Unicode]...The draft of ISO 10646 was not very attractive to us...We chose the Unicode Standard for its technical merits and because its code space was better defined. </p>
	<p> The Unicode Standard defines an adequate character set but an unreasonable representation...We needed a way to adapt the Unicode Standard to the tools-and-pipes model of text processing embodied by the Unix system. To do that, we needed an ASCIIcompatible textual representation of Unicode characters for transmission and storage...</p>
	<p> The UTF encoding has several good properties. By far the most important is that a byte in the ASCII range 0-127 represents itself in UTF. Thus UTF is backward compatible with ASCII. UTF has other advantages. It is a byte encoding and is therefore byte-order independent. ASCII control characters appear in the byte stream only as themselves, never as an element of a sequence encoding another character, so newline bytes separate
lines of UTF text. Finally, ANSI Cs strcmp function applied to UTF strings preserves the ordering of Unicode characters </p>
	</div>
</ul>
</body>
</html>
